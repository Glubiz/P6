"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAsyncSubscribable = void 0;
const ErrorStrategy_1 = require("./ErrorStrategy");
const EventIteratorOptions_1 = require("./EventIteratorOptions");
/**
 * Create a AsyncSubscribable instance that uses the give subscribe and
 * unsubscribe function to manage listeners.
 *
 * @param options -
 *   options used to create this async subscribable
 * @returns
 *   instance of `AsyncSubscribable`
 */
function createAsyncSubscribable(options) {
    var _a;
    const subscribe = options.subscribe;
    const unsubscribe = options.unsubscribe;
    const defaultErrorStrategy = (_a = options.defaultErrorStrategy) !== null && _a !== void 0 ? _a : ErrorStrategy_1.rethrowErrors;
    const subscribable = async (listener) => {
        await subscribe(listener);
        // Return a handle that can be used to unsubscribe
        return {
            async unsubscribe() {
                await unsubscribe(listener);
            }
        };
    };
    subscribable.subscribe = subscribable;
    subscribable.unsubscribe = unsubscribe;
    subscribable.once = () => new Promise((resolve, reject) => {
        const listener = (...args) => {
            unsubscribe(listener)
                .catch(err => reject(err));
            resolve(args);
        };
        subscribe(listener)
            .catch(err => reject(err));
    });
    subscribable.filter = (filter) => createFilteredAsyncSubscribable(subscribe, unsubscribe, filter, defaultErrorStrategy);
    subscribable.withThis = (newThis) => createNewThisAsyncSubscribable(subscribe, unsubscribe, newThis);
    const defaultIteratorOptions = options.defaultIterator;
    subscribable.iterator = (itOptions) => createAsyncIterator(subscribe, unsubscribe, {
        ...defaultIteratorOptions,
        ...itOptions
    });
    subscribable[Symbol.asyncIterator] = () => createAsyncIterator(subscribe, unsubscribe, defaultIteratorOptions);
    return subscribable;
}
exports.createAsyncSubscribable = createAsyncSubscribable;
/**
 * Create a AsyncSubscribable that is filtered via the specified function.
 *
 * @param subscribe -
 *   function used to subscribe listeners
 * @param unsubscribe -
 *   function used to unsubscribe listeners
 * @param filterToApply -
 *   the function used to filter events
 * @param errorStrategy -
 *   error strategy to use when filter or listener triggering fails
 * @returns
 *   `AsyncSubscribable`
 */
function createFilteredAsyncSubscribable(subscribe, unsubscribe, filterToApply, errorStrategy) {
    // Map used to keep track of the filtered listener of an added listener
    const listenerMapping = new Map();
    return createAsyncSubscribable({
        subscribe: listener => {
            const actualListener = async function (...args) {
                try {
                    if (await filterToApply.apply(this, args)) {
                        listener.call(this, ...args);
                    }
                }
                catch (ex) {
                    errorStrategy.handle(ex);
                }
            };
            listenerMapping.set(listener, actualListener);
            return subscribe(actualListener);
        },
        unsubscribe: listener => {
            const actual = listenerMapping.get(listener);
            if (actual) {
                listenerMapping.delete(listener);
                return unsubscribe(actual);
            }
            else {
                return Promise.resolve(undefined);
            }
        }
    });
}
/**
 * Create a AsyncSubscribable that changes what this is used for listeners.
 *
 * @param subscribe -
 *   function used to subscribe listeners
 * @param unsubscribe -
 *   function used to unsubscribe listeners
 * @param newThis -
 *   object to use as the new this
 * @returns
 *   `AsyncSubscribable`
 */
function createNewThisAsyncSubscribable(subscribe, unsubscribe, newThis) {
    // Map used to keep track of the modified listeners
    const listenerMapping = new Map();
    return createAsyncSubscribable({
        subscribe: async (listener) => {
            const actualListener = function (...args) {
                listener.call(newThis, ...args);
            };
            listenerMapping.set(listener, actualListener);
            return await subscribe(actualListener);
        },
        unsubscribe: async (listener) => {
            const actual = listenerMapping.get(listener);
            if (actual) {
                listenerMapping.delete(listener);
                return await unsubscribe(actual);
            }
        }
    });
}
/**
 * Create an async iterator that will register a listener and emit events as
 * they are received.
 *
 * @param subscribe -
 *   function used to subscribe listeners
 * @param unsubscribe -
 *   function used to unsubscribe listeners
 * @param options -
 *   options to apply to this iterator
 * @returns
 *   async iterator
 */
function createAsyncIterator(subscribe, unsubscribe, options) {
    var _a, _b;
    const limit = (_a = options === null || options === void 0 ? void 0 : options.limit) !== null && _a !== void 0 ? _a : 0;
    const behavior = (_b = options === null || options === void 0 ? void 0 : options.overflowBehavior) !== null && _b !== void 0 ? _b : EventIteratorOptions_1.OverflowBehavior.DropOldest;
    const queue = [];
    let current = null;
    let hasRegistered = false;
    let block = null;
    const listener = async (...args) => {
        if (current) {
            current({
                value: args,
                done: false
            });
            current = null;
        }
        else {
            if (limit > 0) {
                if (queue.length >= limit) {
                    switch (behavior) {
                        case EventIteratorOptions_1.OverflowBehavior.DropNewest:
                            return;
                        case EventIteratorOptions_1.OverflowBehavior.DropOldest:
                            queue.shift();
                            break;
                        case EventIteratorOptions_1.OverflowBehavior.Block:
                            await new Promise(resolve => {
                                block = resolve;
                            });
                            break;
                    }
                }
            }
            queue.push(args);
        }
    };
    return {
        async next() {
            if (!hasRegistered) {
                await subscribe(listener);
                hasRegistered = true;
            }
            if (block) {
                // If there's a block, resolve and clear it
                block();
                block = null;
            }
            if (queue.length > 0) {
                // There is data in the queue, pull it
                const result = queue.shift();
                if (!result) {
                    throw new Error('Unexpected error, event queue is empty');
                }
                return {
                    value: result,
                    done: false
                };
            }
            else {
                // Nothing in the queue, register the promise
                return await new Promise(resolve => {
                    current = resolve;
                });
            }
        },
        async return(value) {
            await unsubscribe(listener);
            return {
                value: value,
                done: true
            };
        },
        [Symbol.asyncIterator]() {
            return this;
        }
    };
}
//# sourceMappingURL=createAsyncSubscribable.js.map