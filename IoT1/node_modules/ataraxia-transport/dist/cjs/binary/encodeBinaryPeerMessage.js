"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeBinaryPeerMessage = void 0;
const cbor_1 = require("@stablelib/cbor");
const messages_1 = require("../messages");
const tags_1 = require("./tags");
/**
 * Encode a peer message into a binary format.
 *
 * @param type -
 *   type of peer message
 * @param data -
 *   data of message
 * @returns
 *  buffer with encoded message
 */
function encodeBinaryPeerMessage(type, data) {
    const encoder = new cbor_1.Encoder();
    switch (type) {
        case messages_1.PeerMessageType.Ping:
            encoder.encodeInteger(tags_1.TAG_PING);
            break;
        case messages_1.PeerMessageType.Pong:
            encoder.encodeInteger(tags_1.TAG_PONG);
            break;
        case messages_1.PeerMessageType.Ok:
            encoder.encodeInteger(tags_1.TAG_OK);
            break;
        case messages_1.PeerMessageType.Reject:
            encoder.encodeInteger(tags_1.TAG_REJECT);
            break;
        case messages_1.PeerMessageType.Hello:
            {
                const helloMessage = data;
                encoder.encodeInteger(tags_1.TAG_HELLO);
                encoder.encodeBytes(new Uint8Array(helloMessage.id));
                encoder.encodeInteger(helloMessage.capabilities.size);
                for (const cap of helloMessage.capabilities) {
                    encoder.encodeString(cap);
                }
                break;
            }
        case messages_1.PeerMessageType.Select:
            {
                const selectMessage = data;
                encoder.encodeInteger(tags_1.TAG_SELECT);
                encoder.encodeBytes(new Uint8Array(selectMessage.id));
                encoder.encodeInteger(selectMessage.capabilities.size);
                for (const cap of selectMessage.capabilities) {
                    encoder.encodeString(cap);
                }
                break;
            }
        case messages_1.PeerMessageType.Auth:
            {
                const authMessage = data;
                encoder.encodeInteger(tags_1.TAG_AUTH);
                encoder.encodeString(authMessage.method);
                encoder.encodeBytes(new Uint8Array(authMessage.data));
                break;
            }
        case messages_1.PeerMessageType.AuthData:
            {
                const authDataMessage = data;
                encoder.encodeInteger(tags_1.TAG_AUTH_DATA);
                encoder.encodeBytes(new Uint8Array(authDataMessage.data));
                break;
            }
        case messages_1.PeerMessageType.Begin:
            encoder.encodeInteger(tags_1.TAG_BEGIN);
            break;
        case messages_1.PeerMessageType.Bye:
            encoder.encodeInteger(tags_1.TAG_BYE);
            break;
        case messages_1.PeerMessageType.NodeSummary:
            {
                const nodeSummaryMessage = data;
                encoder.encodeInteger(tags_1.TAG_NODE_SUMMARY);
                encoder.encodeInteger(nodeSummaryMessage.ownVersion);
                encoder.encodeInteger(nodeSummaryMessage.nodes.length);
                for (const routingSummary of nodeSummaryMessage.nodes) {
                    encoder.encodeBytes(new Uint8Array(routingSummary.id));
                    encoder.encodeInteger(routingSummary.version);
                }
                break;
            }
        case messages_1.PeerMessageType.NodeRequest:
            {
                const nodeRequestMessage = data;
                encoder.encodeInteger(tags_1.TAG_NODE_REQUEST);
                encoder.encodeInteger(nodeRequestMessage.nodes.length);
                for (const node of nodeRequestMessage.nodes) {
                    encoder.encodeBytes(new Uint8Array(node));
                }
                break;
            }
        case messages_1.PeerMessageType.NodeDetails:
            {
                const nodeDetailsMessage = data;
                encoder.encodeInteger(tags_1.TAG_NODE_DETAILS);
                encoder.encodeInteger(nodeDetailsMessage.nodes.length);
                for (const node of nodeDetailsMessage.nodes) {
                    encoder.encodeBytes(new Uint8Array(node.id));
                    encoder.encodeInteger(node.version);
                    encoder.encodeInteger(node.neighbors.length);
                    for (const neighbor of node.neighbors) {
                        encoder.encodeBytes(new Uint8Array(neighbor.id));
                        encoder.encodeInteger(neighbor.latency);
                    }
                }
                break;
            }
        case messages_1.PeerMessageType.Data:
            {
                const dataMessage = data;
                encoder.encodeInteger(tags_1.TAG_DATA);
                encoder.encodeBytes(new Uint8Array(dataMessage.target));
                encoder.encodeString(dataMessage.type);
                encoder.encodeBytes(new Uint8Array(dataMessage.data));
                encoder.encodeInteger(dataMessage.path.length);
                for (const entry of dataMessage.path) {
                    encoder.encodeBytes(new Uint8Array(entry.node));
                    encoder.encodeInteger(entry.id);
                }
                break;
            }
        case messages_1.PeerMessageType.DataAck:
            {
                const dataAckMessage = data;
                encoder.encodeInteger(tags_1.TAG_DATA_ACK);
                encoder.encodeInteger(dataAckMessage.id);
                break;
            }
        case messages_1.PeerMessageType.DataReject:
            {
                const dataRejectMessage = data;
                encoder.encodeInteger(tags_1.TAG_DATA_REJECT);
                encoder.encodeInteger(dataRejectMessage.id);
                break;
            }
        default:
            throw new Error('Unknown peer message of type: ' + (messages_1.PeerMessageType[type] || type));
    }
    return encoder.finish().buffer;
}
exports.encodeBinaryPeerMessage = encodeBinaryPeerMessage;
//# sourceMappingURL=encodeBinaryPeerMessage.js.map