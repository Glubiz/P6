/// <reference types="debug" />
import { AuthProvider } from './auth';
import { DisconnectReason } from './DisconnectReason';
import { PeerMessageType, PeerMessage } from './messages';
import { Peer } from './Peer';
import { TransportOptions } from './TransportOptions';
/**
 * Abstract implementation of `Peer`. Used as the basis that negotiates
 * protocol versions and requested features.
 */
export declare abstract class AbstractPeer implements Peer {
    protected readonly transportOptions: TransportOptions;
    protected debug: debug.Debugger;
    private failureDetector;
    id: ArrayBuffer;
    protected version?: number;
    private state;
    private readonly connectEvent;
    private readonly disconnectEvent;
    private readonly dataEvent;
    private lastLatencyTime;
    private latencyValues;
    private helloTimeout;
    private pingSender;
    private pingChecker;
    private lastPing;
    private readonly authProviders;
    private remainingAuthProviders?;
    private authClientFlow?;
    private authServerFlow?;
    /**
     * Create a new peer over the given transport.
     *
     * @param transportOptions -
     *   the transport this belongs to
     * @param authProviders -
     *   `AuthProvider` instances to use to authenticate with the other side
     */
    constructor(transportOptions: TransportOptions, authProviders: ReadonlyArray<AuthProvider>);
    get onConnect(): import("atvik").Subscribable<this, []>;
    get onDisconnect(): import("atvik").Subscribable<this, []>;
    get onData(): import("atvik").Subscribable<this, [PeerMessageType, any]>;
    get connected(): boolean;
    /**
     * Get a buffer representing a publicly known security challenge for the
     * local side of the peer.
     *
     * @returns
     *   buffer with challenge or undefined
     */
    protected localPublicSecurity(): ArrayBuffer | undefined;
    /**
     * Get a buffer representing a publicly known security challenge for the
     * remote side of the peer.
     *
     * @returns
     *   buffer with challenge or undefined
     */
    protected remotePublicSecurity(): ArrayBuffer | undefined;
    /**
     * Manually disconnect this peer.
     */
    disconnect(): void;
    /**
     * Request that this peer disconnects.
     *
     * @param reason -
     *   the reason why this disconnect is happening
     * @param err -
     *   optional error recorded
     */
    protected abstract requestDisconnect(reason: DisconnectReason, err?: Error): void;
    /**
     * Handle disconnect event. This implementation will log info about the
     * disconnect and then mark the peer as disconnected.
     *
     * Transports may override this to provide reconnection behavior.
     *
     * @param reason -
     *   the reason why this disconnect happened
     * @param err -
     *   optional error recorded
     */
    protected handleDisconnect(reason: DisconnectReason, err?: Error): void;
    protected queueNegotiationTimeout(): void;
    /**
     * Abort a connection.
     *
     * @param message -
     *   message for logging purposes
     * @param error -
     *   optional error recording
     * @param reason -
     *   reason for disconnect
     */
    protected abort(message: string, error?: unknown, reason?: DisconnectReason): void;
    /**
     * Initiate negotiation as the server. This will send the initial Hello
     * to the client and this peer will start waiting for a reply.
     */
    protected negotiateAsServer(): void;
    /**
     * Initiate negotiation as the client. This will switch the peer into a
     * client mode and wait for the initial Hello from the server.
     */
    protected negotiateAsClient(): void;
    /**
     * Receive a message from the peer. This will method is responsible for
     * checking the state of the peer and routing messages to their correct
     * locations.
     *
     * @param type -
     *   type of message received
     * @param payload -
     *   data of message received
     */
    protected receiveData(type: PeerMessageType, payload: any): void;
    /**
     * Client flow: HELLO received. A HELLO with information about the server
     * has been received. Process and send back a reply.
     *
     * @param message -
     */
    private receiveHello;
    /**
     * Server flow: SELECT received. The client as picked the capabilities it
     * wants and is ready to proceed.
     *
     * @param message -
     */
    private receiveSelect;
    /**
     * Client flow: OK after SELECT. The server has received our SELECT and
     * replied with an OK.
     */
    private receiveSelectOK;
    /**
     * Pick the next provider to use for authentication.
     *
     * @returns
     *   the next provider to try or `null`
     */
    private pickNextAuthProvider;
    private sendInitialAuth;
    /**
     * Client flow: Server accepted our authentication.
     */
    private receiveAuthOk;
    /**
     * Client flow: Server rejected our authentication. Try another one.
     */
    private receiveAuthReject;
    /**
     * Client flow: AUTHDATA has been received from the server.
     *
     * @param message -
     */
    private receiveServerAuthData;
    /**
     * Server flow: AUTH has been received from client.
     *
     * @param message -
     */
    private receiveAuth;
    private handleSendingAuthReply;
    /**
     * Server flow: AUTHDATA has been received from client.
     *
     * @param message -
     */
    private receiveClientAuthData;
    private switchToActive;
    /**
     * Callback for when a peer has connected.
     */
    protected didConnect(): void;
    /**
     * Force a connection without performing negotiation.
     *
     * @param id -
     *   identifier of the peer
     */
    protected forceConnect(id: ArrayBuffer): void;
    /**
     * Send a ping to the peer.
     */
    private sendPing;
    /**
     * Receive a ping and send a pong response.
     */
    private receivePing;
    /**
     * Receive a pong from a sent ping.
     */
    private receivePong;
    /**
     * Check if this peer can be considered failed and request us to be
     * disconnected from it.
     */
    private checkFailure;
    /**
     * Register that a latency request has been sent, such as a ping.
     */
    private registerLatencySend;
    /**
     * Register that a latency reply has been received, such as a pong.
     */
    private registerLatencyReply;
    /**
     * Get the current latency.
     *
     * @returns
     *   estimated latency to the peer in milliseconds
     */
    get latency(): number;
    /**
     * Send data to this peer.
     *
     * @param type -
     *   type of message being sent
     * @param payload -
     *   data of message
     */
    abstract send<T extends PeerMessageType>(type: T, payload: PeerMessage<T>): Promise<void>;
}
//# sourceMappingURL=AbstractPeer.d.ts.map