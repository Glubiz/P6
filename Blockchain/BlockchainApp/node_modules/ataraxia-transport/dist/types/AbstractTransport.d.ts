import debug from 'debug';
import { Peer } from './Peer';
import { Transport } from './Transport';
import { TransportOptions } from './TransportOptions';
/**
 * Abstract base for implementing transports. Implements common behavior to
 * help with tracking of peers.
 */
export declare class AbstractTransport implements Transport {
    private readonly transportName;
    private readonly peerConnectEvent;
    protected debug: debug.Debugger;
    private _started;
    protected readonly peers: Set<Peer>;
    private _transportOptions?;
    /**
     * Create a new instance.
     *
     * @param name -
     *   name of the transport, should be short and identify, examples from the
     *   core library include `local`, `tcp` and `hyperswarm`.
     */
    constructor(name: string);
    get transportOptions(): TransportOptions;
    /**
     * Event for when a new peer is connected via this transport.
     *
     * @returns
     *   `Subscribable` that can be used to register listeners
     */
    get onPeerConnect(): import("atvik").Subscribable<this, [peer: Peer]>;
    /**
     * Get if transport is started.
     *
     * @returns
     *   `true` if transport is started
     */
    get started(): boolean;
    /**
     * Start this transport.
     *
     * @param options -
     *   options as generated by the network instance
     * @returns
     *   boolean indicating if the transport was started
     */
    start(options: TransportOptions): Promise<boolean>;
    /**
     * Stop this transport.
     *
     * @returns
     *   boolean indicating if the transport was stopped.
     */
    stop(): Promise<boolean>;
    /**
     * Add a peer to this transport. This will start monitoring this peer
     * for connection events and make it available/unavailable as it
     * connects/disconnects.
     *
     * @param peer -
     *   peer to track
     */
    protected addPeer(peer: Peer): void;
}
//# sourceMappingURL=AbstractTransport.d.ts.map