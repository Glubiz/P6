"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractPeer = void 0;
const adaptive_accrual_failure_detector_1 = require("adaptive-accrual-failure-detector");
const atvik_1 = require("atvik");
const debug_1 = require("debug");
const auth_1 = require("./auth");
const DisconnectReason_1 = require("./DisconnectReason");
const ids_1 = require("./ids");
const messages_1 = require("./messages");
/**
 * The interval at which pings are sent.
 */
const pingInterval = 30000;
/**
 * The interval at which pings are checked.
 */
const pingCheckInterval = 5000;
/**
 * The maximum time before a ping must have been received.
 */
const pingMaxTime = pingInterval * 3;
/**
 * Abstract implementation of `Peer`. Used as the basis that negotiates
 * protocol versions and requested features.
 */
class AbstractPeer {
    /**
     * Create a new peer over the given transport.
     *
     * @param transportOptions -
     *   the transport this belongs to
     * @param authProviders -
     *   `AuthProvider` instances to use to authenticate with the other side
     */
    constructor(transportOptions, authProviders) {
        this.transportOptions = transportOptions;
        this.debug = (0, debug_1.debug)(transportOptions.debugNamespace + ':peer:pending');
        this.authProviders = authProviders;
        this.state = 0 /* Initial */;
        this.connectEvent = new atvik_1.Event(this);
        this.disconnectEvent = new atvik_1.Event(this);
        this.dataEvent = new atvik_1.Event(this);
        this.id = (0, ids_1.noId)();
        this.failureDetector = new adaptive_accrual_failure_detector_1.FailureDetector();
        this.lastLatencyTime = Date.now();
        this.latencyValues = [];
        this.lastPing = 0;
    }
    get onConnect() {
        return this.connectEvent.subscribable;
    }
    get onDisconnect() {
        return this.disconnectEvent.subscribable;
    }
    get onData() {
        return this.dataEvent.subscribable;
    }
    get connected() {
        return this.state === 8 /* Active */;
    }
    /**
     * Get a buffer representing a publicly known security challenge for the
     * local side of the peer.
     *
     * @returns
     *   buffer with challenge or undefined
     */
    localPublicSecurity() {
        return undefined;
    }
    /**
     * Get a buffer representing a publicly known security challenge for the
     * remote side of the peer.
     *
     * @returns
     *   buffer with challenge or undefined
     */
    remotePublicSecurity() {
        return undefined;
    }
    /**
     * Manually disconnect this peer.
     */
    disconnect() {
        this.debug('Requesting disconnect from peer');
    }
    /**
     * Handle disconnect event. This implementation will log info about the
     * disconnect and then mark the peer as disconnected.
     *
     * Transports may override this to provide reconnection behavior.
     *
     * @param reason -
     *   the reason why this disconnect happened
     * @param err -
     *   optional error recorded
     */
    handleDisconnect(reason, err) {
        this.debug('Disconnected', 'reason=', DisconnectReason_1.DisconnectReason[reason], 'error=', err);
        clearTimeout(this.helloTimeout);
        clearInterval(this.pingSender);
        clearInterval(this.pingChecker);
        const wasActive = this.state === 8 /* Active */;
        this.state = 0 /* Initial */;
        if (wasActive) {
            this.disconnectEvent.emit();
        }
    }
    queueNegotiationTimeout() {
        // Wait a few seconds for the hello from the other side
        if (this.helloTimeout) {
            clearTimeout(this.helloTimeout);
        }
        this.helloTimeout = setTimeout(() => this.abort('Timeout during negotiation'), 5000);
    }
    /**
     * Abort a connection.
     *
     * @param message -
     *   message for logging purposes
     * @param error -
     *   optional error recording
     * @param reason -
     *   reason for disconnect
     */
    abort(message, error, reason = DisconnectReason_1.DisconnectReason.NegotiationFailed) {
        clearTimeout(this.helloTimeout);
        this.debug(message, 'reason=', DisconnectReason_1.DisconnectReason[reason], 'error=', error);
        this.requestDisconnect(reason, error instanceof Error ? error : new Error(String(error)));
    }
    /**
     * Initiate negotiation as the server. This will send the initial Hello
     * to the client and this peer will start waiting for a reply.
     */
    negotiateAsServer() {
        this.debug = (0, debug_1.debug)(this.transportOptions.debugNamespace + ':peer:pending:server');
        this.state = 6 /* WaitingForSelect */;
        // Write the hello message
        const message = {
            id: this.transportOptions.networkId,
            capabilities: new Set()
        };
        this.send(messages_1.PeerMessageType.Hello, message)
            .catch(err => this.abort('Unable to send HELLO to client', err));
        this.queueNegotiationTimeout();
    }
    /**
     * Initiate negotiation as the client. This will switch the peer into a
     * client mode and wait for the initial Hello from the server.
     */
    negotiateAsClient() {
        this.debug = (0, debug_1.debug)(this.transportOptions.debugNamespace + ':peer:pending:client');
        this.registerLatencySend();
        this.state = 1 /* WaitingForHello */;
        this.queueNegotiationTimeout();
    }
    /**
     * Receive a message from the peer. This will method is responsible for
     * checking the state of the peer and routing messages to their correct
     * locations.
     *
     * @param type -
     *   type of message received
     * @param payload -
     *   data of message received
     */
    receiveData(type, payload) {
        this.debug('Incoming', messages_1.PeerMessageType[type], 'with payload', payload);
        switch (type) {
            case messages_1.PeerMessageType.Bye:
                this.requestDisconnect(DisconnectReason_1.DisconnectReason.Manual);
                break;
            case messages_1.PeerMessageType.Ping:
                this.receivePing();
                break;
            case messages_1.PeerMessageType.Pong:
                this.receivePong();
                break;
            case messages_1.PeerMessageType.Hello:
                if (this.state === 1 /* WaitingForHello */) {
                    this.receiveHello(payload);
                }
                else {
                    this.abort('Received unexpected HELLO');
                }
                break;
            case messages_1.PeerMessageType.Select:
                if (this.state === 6 /* WaitingForSelect */) {
                    this.receiveSelect(payload);
                }
                else {
                    this.abort('Received unexpected SELECT');
                }
                break;
            case messages_1.PeerMessageType.Auth:
                if (this.state === 3 /* WaitingForAuth */) {
                    this.receiveAuth(payload);
                }
                else {
                    this.abort('Received unexpected AUTH');
                }
                break;
            case messages_1.PeerMessageType.AuthData:
                if (this.state === 4 /* WaitingForAuthData */) {
                    this.receiveClientAuthData(payload);
                }
                else if (this.state === 7 /* WaitingForAuthAck */) {
                    this.receiveServerAuthData(payload);
                }
                else {
                    this.abort('Received unexpected AUTHDATA');
                }
                break;
            case messages_1.PeerMessageType.Begin:
                if (this.state === 5 /* WaitingForBegin */) {
                    this.registerLatencyReply();
                    this.switchToActive();
                }
                else {
                    this.abort('Received unexpected BEGIN');
                }
                break;
            case messages_1.PeerMessageType.Ok:
                if (this.state === 2 /* WaitingForSelectAck */) {
                    this.receiveSelectOK();
                }
                else if (this.state === 7 /* WaitingForAuthAck */) {
                    this.receiveAuthOk();
                }
                else {
                    this.abort('Received unexpected OK');
                }
                break;
            case messages_1.PeerMessageType.Reject:
                if (this.state === 2 /* WaitingForSelectAck */) {
                    this.abort('SELECT was rejected by server');
                }
                else if (this.state === 7 /* WaitingForAuthAck */) {
                    this.receiveAuthReject();
                }
                else {
                    this.abort('Received unexpected REJECT');
                }
                break;
            default:
                this.dataEvent.emit(type, payload);
        }
    }
    /**
     * Client flow: HELLO received. A HELLO with information about the server
     * has been received. Process and send back a reply.
     *
     * @param message -
     */
    receiveHello(message) {
        // Set the identifier and the version of the protocol to use
        this.id = message.id;
        // Update debugging with the identifier of the peer
        this.debug = (0, debug_1.debug)(this.transportOptions.debugNamespace + ':peer:' + (0, ids_1.encodeId)(this.id) + ':client');
        // TODO: Select capabilities wanted
        const capabilities = new Set();
        // Switch state to waiting for the OK from the server
        this.state = 2 /* WaitingForSelectAck */;
        // Send our reply
        const reply = {
            id: this.transportOptions.networkId,
            capabilities: capabilities
        };
        // Measure the latency between the sending of SELECT and OK from server
        this.registerLatencySend();
        this.send(messages_1.PeerMessageType.Select, reply)
            .catch(err => this.abort('Unable to send SELECT reply', err));
        // Requeue a timeout for the negotiation
        this.queueNegotiationTimeout();
    }
    /**
     * Server flow: SELECT received. The client as picked the capabilities it
     * wants and is ready to proceed.
     *
     * @param message -
     */
    receiveSelect(message) {
        // Update the id of this peer with the client one
        this.id = message.id;
        // Update debugging with the identifier of the peer
        this.debug = (0, debug_1.debug)(this.transportOptions.debugNamespace + ':peer:' + (0, ids_1.encodeId)(this.id) + ':server');
        // TODO: Handle incoming capabilities
        // Next step is to wait for the client to request authentication
        this.state = 3 /* WaitingForAuth */;
        // Simple OK reply expected by the client
        this.send(messages_1.PeerMessageType.Ok, undefined)
            .catch(err => this.abort('Unable to send OK', err));
        // Requeue a timeout for the negotiation
        this.queueNegotiationTimeout();
    }
    /**
     * Client flow: OK after SELECT. The server has received our SELECT and
     * replied with an OK.
     */
    receiveSelectOK() {
        // Register the time it took for the server to ok
        this.registerLatencyReply();
        this.state = 7 /* WaitingForAuthAck */;
        // Assign the initial providers and send our initial auth
        this.remainingAuthProviders = this.authProviders.slice();
        this.sendInitialAuth();
    }
    /**
     * Pick the next provider to use for authentication.
     *
     * @returns
     *   the next provider to try or `null`
     */
    pickNextAuthProvider() {
        if (!this.remainingAuthProviders) {
            return null;
        }
        // eslint-disable-next-line no-constant-condition
        while (true) {
            if (this.remainingAuthProviders.length === 0)
                return null;
            const provider = this.remainingAuthProviders[0];
            this.remainingAuthProviders.splice(0, 1);
            if (provider.createClientFlow) {
                return provider;
            }
        }
    }
    sendInitialAuth() {
        const provider = this.pickNextAuthProvider();
        if (provider && provider.createClientFlow) {
            const authClientFlow = provider.createClientFlow({
                localPublicSecurity: this.localPublicSecurity(),
                remotePublicSecurity: this.remotePublicSecurity()
            });
            this.authClientFlow = authClientFlow;
            // Get the initial message and send the request to the server
            (async () => {
                let msg;
                try {
                    msg = await authClientFlow.initialMessage();
                }
                catch (err) {
                    this.abort('Initial auth message failed', err);
                    return;
                }
                try {
                    await this.send(messages_1.PeerMessageType.Auth, {
                        method: provider.id,
                        data: msg
                    });
                }
                catch (err) {
                    this.abort('Could not get or send initial auth message', err);
                }
            })().catch(err => this.abort('Unexpected error', err));
            // Queue a negotiation timeout
            this.queueNegotiationTimeout();
        }
        else {
            this.abort('Could not authenticate with any activate provider', undefined, DisconnectReason_1.DisconnectReason.AuthReject);
        }
    }
    /**
     * Client flow: Server accepted our authentication.
     */
    receiveAuthOk() {
        this.send(messages_1.PeerMessageType.Begin, undefined)
            .then(() => this.switchToActive())
            .catch(err => this.abort('Sending BEGIN failed', err));
    }
    /**
     * Client flow: Server rejected our authentication. Try another one.
     */
    receiveAuthReject() {
        this.sendInitialAuth();
    }
    /**
     * Client flow: AUTHDATA has been received from the server.
     *
     * @param message -
     */
    receiveServerAuthData(message) {
        (async () => {
            if (!this.authClientFlow) {
                this.abort('No client flow available and server sent AUTHDATA');
                return;
            }
            let reply;
            try {
                reply = await this.authClientFlow.receiveData(message.data);
            }
            catch (err) {
                this.abort('Error while handling auth data', err);
                return;
            }
            if (reply.type === auth_1.AuthClientReplyType.Data) {
                try {
                    await this.send(messages_1.PeerMessageType.AuthData, {
                        data: reply.data
                    });
                }
                catch (err) {
                    this.abort('Error while sending auth reply', err);
                }
            }
            else if (reply.type === auth_1.AuthClientReplyType.Reject) {
                // Retry the next authentication method
                this.sendInitialAuth();
            }
        })().catch(err => this.abort('Unexpected error', err));
        this.queueNegotiationTimeout();
    }
    /**
     * Server flow: AUTH has been received from client.
     *
     * @param message -
     */
    receiveAuth(message) {
        (async () => {
            if (this.authServerFlow) {
                try {
                    await this.authServerFlow.destroy();
                }
                catch (err) {
                    this.debug('Error while releasing server auth flow', err);
                }
            }
            let provider;
            for (const p of this.authProviders) {
                if (p.id === message.method) {
                    provider = p;
                    break;
                }
            }
            if (!provider || !provider.createServerFlow) {
                // This provider does not exist, reject the authentication attempt
                this.send(messages_1.PeerMessageType.Reject, undefined)
                    .catch(err => this.abort('Could not send REJECT', err));
                this.queueNegotiationTimeout();
                return;
            }
            const authServerFlow = provider.createServerFlow({
                localPublicSecurity: this.localPublicSecurity(),
                remotePublicSecurity: this.remotePublicSecurity()
            });
            this.authServerFlow = authServerFlow;
            let reply;
            try {
                reply = await authServerFlow.receiveInitial(message.data);
            }
            catch (err) {
                this.abort('Error while handling initial auth', err);
                return;
            }
            try {
                await this.handleSendingAuthReply(reply);
            }
            catch (err) {
                this.abort('Error while sending auth reply', err);
            }
        })().catch(err => this.abort('Unexpected error', err));
        this.queueNegotiationTimeout();
    }
    handleSendingAuthReply(reply) {
        switch (reply.type) {
            case auth_1.AuthServerReplyType.Ok:
                // Authentication passed
                this.registerLatencySend();
                this.state = 5 /* WaitingForBegin */;
                return this.send(messages_1.PeerMessageType.Ok, undefined);
            case auth_1.AuthServerReplyType.Reject:
                // Authentication was rejected, switch back to waiting for another auth
                this.state = 3 /* WaitingForAuth */;
                return this.send(messages_1.PeerMessageType.Reject, undefined);
            case auth_1.AuthServerReplyType.Data:
                // Extra data to pass back to the client
                this.state = 4 /* WaitingForAuthData */;
                if (!reply.data) {
                    this.abort('Auth provider returned data reply without any data');
                    return Promise.reject();
                }
                return this.send(messages_1.PeerMessageType.AuthData, {
                    data: reply.data
                });
        }
        throw new Error('Unknown type of reply');
    }
    /**
     * Server flow: AUTHDATA has been received from client.
     *
     * @param message -
     */
    receiveClientAuthData(message) {
        (async () => {
            if (!this.authServerFlow) {
                this.abort('No server flow active and client sent AUTHDATA');
                return;
            }
            let reply;
            try {
                reply = await this.authServerFlow.receiveData(message.data);
            }
            catch (err) {
                this.abort('Error while handling auth data', err);
                return;
            }
            try {
                await this.handleSendingAuthReply(reply);
            }
            catch (err) {
                this.abort('Error while sending auth reply', err);
            }
        })().catch(err => this.abort('Unexpected error', err));
        this.queueNegotiationTimeout();
    }
    switchToActive() {
        this.debug('Switching to active');
        // Make sure the timeout won't be triggered
        clearTimeout(this.helloTimeout);
        this.helloTimeout = undefined;
        // Notify the peer that it has been connected
        this.didConnect();
        // Switch to active state
        this.state = 8 /* Active */;
        if (this.authClientFlow) {
            this.authClientFlow.destroy()
                .catch(err => this.debug('Error while releasing client auth flow', err));
        }
        if (this.authServerFlow) {
            this.authServerFlow.destroy()
                .catch(err => this.debug('Error while releasing server auth flow', err));
        }
        // Setup ping sending
        this.failureDetector.registerHeartbeat();
        this.lastPing = Date.now();
        this.pingChecker = setInterval(this.checkFailure.bind(this), pingCheckInterval);
        this.pingSender = setInterval(this.sendPing.bind(this), pingInterval);
        // Emit the connect event
        this.connectEvent.emit();
    }
    /**
     * Callback for when a peer has connected.
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    didConnect() {
    }
    /**
     * Force a connection without performing negotiation.
     *
     * @param id -
     *   identifier of the peer
     */
    forceConnect(id) {
        this.id = id;
        this.debug = (0, debug_1.debug)(this.transportOptions.debugNamespace + ':peer:' + (0, ids_1.encodeId)(this.id) + ':client');
        this.latencyValues.push(0);
        this.switchToActive();
    }
    /**
     * Send a ping to the peer.
     */
    sendPing() {
        this.registerLatencySend();
        this.send(messages_1.PeerMessageType.Ping, undefined)
            .catch(err => this.debug('Caught error while sending ping', err));
    }
    /**
     * Receive a ping and send a pong response.
     */
    receivePing() {
        this.lastPing = Date.now();
        this.failureDetector.registerHeartbeat();
        this.send(messages_1.PeerMessageType.Pong, undefined)
            .catch(err => this.debug('Caught error while sending pong', err));
    }
    /**
     * Receive a pong from a sent ping.
     */
    receivePong() {
        this.registerLatencyReply();
    }
    /**
     * Check if this peer can be considered failed and request us to be
     * disconnected from it.
     */
    checkFailure() {
        if (this.failureDetector.checkFailure() || this.lastPing + pingMaxTime < Date.now()) {
            this.requestDisconnect(DisconnectReason_1.DisconnectReason.PingTimeout, new Error('Timeout due to no ping'));
        }
    }
    /**
     * Register that a latency request has been sent, such as a ping.
     */
    registerLatencySend() {
        this.lastLatencyTime = Date.now();
    }
    /**
     * Register that a latency reply has been received, such as a pong.
     */
    registerLatencyReply() {
        const time = Date.now();
        if (this.latencyValues.length > 5) {
            this.latencyValues.splice(0, 1);
        }
        this.latencyValues.push(time - this.lastLatencyTime);
    }
    /**
     * Get the current latency.
     *
     * @returns
     *   estimated latency to the peer in milliseconds
     */
    get latency() {
        if (this.latencyValues.length === 0) {
            throw new Error('Latency unknown');
        }
        let sum = 0;
        for (const v of this.latencyValues) {
            sum += v;
        }
        return Math.floor(sum / this.latencyValues.length);
    }
}
exports.AbstractPeer = AbstractPeer;
//# sourceMappingURL=AbstractPeer.js.map