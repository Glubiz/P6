"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSubscribable = void 0;
const ErrorStrategy_1 = require("./ErrorStrategy");
const EventIteratorOptions_1 = require("./EventIteratorOptions");
/**
 * Create a Subscribable given a subscribe, unsubscribe and a once function.
 *
 * @param options -
 *   options used to create this subscribable
 * @returns
 *   instance of `Subscribable`
 */
function createSubscribable(options) {
    var _a;
    const subscribe = options.subscribe;
    const unsubscribe = options.unsubscribe;
    const defaultErrorStrategy = (_a = options.defaultErrorStrategy) !== null && _a !== void 0 ? _a : ErrorStrategy_1.rethrowErrors;
    const subscribable = (listener) => {
        subscribe(listener);
        // Return a handle that can be used to unsubscribe
        return {
            unsubscribe() {
                unsubscribe(listener);
            }
        };
    };
    subscribable.subscribe = subscribable;
    subscribable.unsubscribe = unsubscribe;
    subscribable.once = () => new Promise(resolve => {
        const listener = (...args) => {
            unsubscribe(listener);
            resolve(args);
        };
        subscribe(listener);
    });
    subscribable.filter = (filter) => createFilteredSubscribable(subscribe, unsubscribe, filter, defaultErrorStrategy);
    subscribable.withThis = (newThis) => createNewThisSubscribable(subscribe, unsubscribe, newThis);
    const defaultIteratorOptions = options.defaultIterator;
    subscribable.iterator = (itOptions) => createAsyncIterator(subscribe, unsubscribe, {
        ...defaultIteratorOptions,
        ...itOptions
    });
    subscribable[Symbol.asyncIterator] = () => createAsyncIterator(subscribe, unsubscribe, defaultIteratorOptions);
    return subscribable;
}
exports.createSubscribable = createSubscribable;
/**
 * Create a Subscribable that is filtered via the specified function.
 *
 * @param subscribe -
 *   function used to subscribe listeners
 * @param unsubscribe -
 *   function used to unsubscribe listeners
 * @param filterToApply -
 *   function used to filter events
 * @param errorStrategy -
 *   error strategy to use when filter or listener triggering fails
 * @returns
 *   `Subscribable`
 */
function createFilteredSubscribable(subscribe, unsubscribe, filterToApply, errorStrategy) {
    // Map used to keep track of the filtered listener of an added listener
    const listenerMapping = new Map();
    return createSubscribable({
        subscribe: listener => {
            const actualListener = function (...args) {
                const f = filterToApply.apply(this, args);
                if (typeof f === 'boolean') {
                    if (f) {
                        listener.call(this, ...args);
                    }
                }
                else {
                    return f.then(v => {
                        if (v) {
                            listener.call(this, ...args);
                        }
                    }).catch(ex => errorStrategy.handle(ex));
                }
            };
            listenerMapping.set(listener, actualListener);
            subscribe(actualListener);
        },
        unsubscribe: listener => {
            const actual = listenerMapping.get(listener);
            if (actual) {
                listenerMapping.delete(listener);
                unsubscribe(actual);
            }
        }
    });
}
/**
 * Create a Subscribable that changes what this is used for listeners.
 *
 * @param subscribe -
 *   function used to subscribe listeners
 * @param unsubscribe -
 *   function used to unsubscribe listeners
 * @param newThis -
 *   object to use as the new this
 * @returns
 *   `Subscribable`
 */
function createNewThisSubscribable(subscribe, unsubscribe, newThis) {
    // Map used to keep track of the modified listeners
    const listenerMapping = new Map();
    return createSubscribable({
        subscribe: listener => {
            const actualListener = function (...args) {
                listener.call(newThis, ...args);
            };
            listenerMapping.set(listener, actualListener);
            subscribe(actualListener);
        },
        unsubscribe: listener => {
            const actual = listenerMapping.get(listener);
            if (actual) {
                listenerMapping.delete(listener);
                unsubscribe(actual);
            }
        }
    });
}
/**
 * Create an async iterator that will register a listener and emit events as
 * they are received.
 *
 * @param subscribe -
 *   function used to subscribe listeners
 * @param unsubscribe -
 *   function used to unsubscribe listeners
 * @param options -
 *   options to apply to this iterator
 * @returns
 *   async iterator
 */
function createAsyncIterator(subscribe, unsubscribe, options) {
    var _a, _b;
    const limit = (_a = options === null || options === void 0 ? void 0 : options.limit) !== null && _a !== void 0 ? _a : 0;
    const behavior = (_b = options === null || options === void 0 ? void 0 : options.overflowBehavior) !== null && _b !== void 0 ? _b : EventIteratorOptions_1.OverflowBehavior.DropOldest;
    if (behavior === EventIteratorOptions_1.OverflowBehavior.Block) {
        throw new Error('Blocking is not a supported strategy for non-async events');
    }
    const queue = [];
    let current = null;
    const listener = (...args) => {
        if (current) {
            current({
                value: args,
                done: false
            });
            current = null;
        }
        else {
            if (limit > 0) {
                if (queue.length >= limit) {
                    switch (behavior) {
                        case EventIteratorOptions_1.OverflowBehavior.DropNewest:
                            return;
                        case EventIteratorOptions_1.OverflowBehavior.DropOldest:
                            queue.shift();
                            break;
                    }
                }
            }
            queue.push(args);
        }
    };
    subscribe(listener);
    return {
        next() {
            if (queue.length > 0) {
                // There is data in the queue, pull it
                const result = queue.shift();
                if (!result) {
                    return Promise.reject('Unexpected error, event queue is empty');
                }
                return Promise.resolve({
                    value: result,
                    done: false
                });
            }
            else {
                // Nothing in the queue, register the promise
                return new Promise(resolve => {
                    current = resolve;
                });
            }
        },
        async return(value) {
            unsubscribe(listener);
            return {
                value: value,
                done: true
            };
        },
        [Symbol.asyncIterator]() {
            return this;
        }
    };
}
//# sourceMappingURL=createSubscribable.js.map