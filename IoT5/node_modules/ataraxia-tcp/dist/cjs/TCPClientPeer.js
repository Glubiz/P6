"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TCPClientPeer = void 0;
const net_1 = require("net");
const ataraxia_transport_1 = require("ataraxia-transport");
const ataraxia_transport_streams_1 = require("ataraxia-transport-streams");
/**
 * Peer for TCP transport, used for outgoing connections to a server.
 */
class TCPClientPeer extends ataraxia_transport_streams_1.EncryptedStreamingPeer {
    constructor(options, authProviders, addresses) {
        super(options, authProviders);
        this.backOff = new ataraxia_transport_1.BackOff({
            delay: 100,
            maxDelay: 30000
        });
        this.addresses = addresses;
        this.addressAttempt = 0;
        this.tryConnect();
    }
    handleDisconnect(reason, err) {
        // Make sure that parent peer is disconnected
        super.handleDisconnect(reason, err);
        // Only continue with reconnect if not disconnected and we have addresses to try
        if (this.disconnected || this.addresses.length === 0)
            return;
        this.addressAttempt++;
        if (this.addressAttempt < this.addresses.length) {
            this.debug('Attempting to connect to next address');
            this.tryConnect();
        }
        else {
            const delay = this.backOff.nextDelay();
            this.debug('No more addresses to try, trying in', delay, 'ms');
            this.addressAttempt = 0;
            this.connectTimeout = setTimeout(() => this.tryConnect(), delay);
        }
    }
    /**
     * Attempt to connect to a server, will try addresses in order.
     */
    tryConnect() {
        clearTimeout(this.connectTimeout);
        // Only continue if we have some addresses we know of
        if (this.addresses.length === 0)
            return;
        const address = this.addresses[this.addressAttempt];
        this.debug('Attempting connect to ' + address.host + ':' + address.port);
        const client = (0, net_1.connect)({
            host: address.host,
            port: address.port
        });
        client.setKeepAlive(true);
        client.on('connect', () => {
            this.debug('Negotiating connection via ' + address.host + ':' + address.port);
        });
        this.debug('Connected via ' + address.host + ':' + address.port);
        this.setStream(client, true);
    }
    didConnect() {
        this.addressAttempt--;
        this.backOff.reset();
    }
    disconnect() {
        this.stopConnecting();
        super.disconnect();
    }
    stopConnecting() {
        this.addresses = [];
        clearTimeout(this.connectTimeout);
    }
}
exports.TCPClientPeer = TCPClientPeer;
//# sourceMappingURL=TCPClientPeer.js.map