declare const options: unique symbol;
declare const samples: unique symbol;
declare const freshnessPoint: unique symbol;
/**
 * Options that can be used with the failure detector.
 */
export interface FailureDetectorOptions {
    /**
     * Number of samples to keep in the detector. Used when calculating the
     * probability that something has failed. A higher number of samples
     * means the probability calculation is more stable but also means increased
     * memory usage. Defaults to 1000.
     */
    sampleSize?: number;
    /**
     * The scaling factor to use, helps with overestimation of failure
     * probability. Defaults to 0.9.
     */
    scalingFactor?: number;
    /**
     * The threshold that must be met to consider it a failure. If the
     * probability of failure is above this the thing being monitored is
     * considered failed. Defaults to 0.5.
     */
    failureThreshold?: number;
}
/**
 * Failure detector for detecting the failure of processes, connections
 * and distributed systems. This implementation uses an adaptive accrual
 * algorithm.
 *
 * The design of the detector is such that it expects to receive a heartbeat
 * at a certain interval. The detector can then be queried to see if the
 * thing be monitored should be considered failed.
 */
export declare class FailureDetector {
    /**
     * Resolved options for this failure detector.
     */
    private [options];
    /**
     * Samples that have been received, deltas in milliseconds between
     * heartbeats.
     */
    private [samples];
    /**
     * Freshness point, the timestamp in milliseconds of the last heartbeat
     * received.
     */
    private [freshnessPoint];
    constructor(opts?: FailureDetectorOptions);
    /**
     * Register a heartbeat received from the thing being monitored.
     *
     * @param {Number} timestamp
     *   the time at which the heartbeat was received
     */
    registerHeartbeat(timestamp?: number): void;
    /**
     * Calculate the probability that the thing being monitored has failed.
     *
     * @param {Number} timestamp
     *   the current time
     */
    calculateFailureProbability(timestamp?: number): number;
    /**
     * Check if a failure has occurred. This calculates the probability of a
     * failure and returns if is equal to or higher than `failureThreshold`.
     *
     * @param {Number} timestamp
     *   the current time
     */
    checkFailure(timestamp?: number): boolean;
}
export {};
