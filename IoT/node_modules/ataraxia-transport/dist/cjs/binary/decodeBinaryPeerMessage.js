"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeBinaryPeerMessage = void 0;
const cbor_1 = require("@stablelib/cbor");
const messages_1 = require("../messages");
const tags_1 = require("./tags");
/**
 * Decode a peer message from the given buffer.
 *
 * @param data -
 *   buffer containing a previously encoded peer message
 * @returns
 *   array with type of peer message followed by the data of the message
 */
function decodeBinaryPeerMessage(data) {
    const decoder = new cbor_1.Decoder(new Uint8Array(data), {
        ignoreExtraData: true
    });
    const tag = decodeInteger(decoder);
    switch (tag) {
        case tags_1.TAG_PING:
            return [messages_1.PeerMessageType.Ping, undefined];
        case tags_1.TAG_PONG:
            return [messages_1.PeerMessageType.Pong, undefined];
        case tags_1.TAG_OK:
            return [messages_1.PeerMessageType.Ok, undefined];
        case tags_1.TAG_REJECT:
            return [messages_1.PeerMessageType.Reject, undefined];
        case tags_1.TAG_HELLO:
            return [messages_1.PeerMessageType.Hello, {
                    id: decodeId(decoder),
                    capabilities: new Set(decodeArray(decoder, () => decodeString(decoder)))
                }];
        case tags_1.TAG_SELECT:
            return [messages_1.PeerMessageType.Select, {
                    id: decodeId(decoder),
                    capabilities: new Set(decodeArray(decoder, () => decodeString(decoder)))
                }];
        case tags_1.TAG_AUTH:
            return [messages_1.PeerMessageType.Auth, {
                    method: decodeString(decoder),
                    data: decodeBuffer(decoder)
                }];
        case tags_1.TAG_AUTH_DATA:
            return [messages_1.PeerMessageType.AuthData, {
                    data: decodeBuffer(decoder)
                }];
        case tags_1.TAG_BEGIN:
            return [messages_1.PeerMessageType.Begin, undefined];
        case tags_1.TAG_BYE:
            return [messages_1.PeerMessageType.Bye, undefined];
        case tags_1.TAG_NODE_SUMMARY:
            return [messages_1.PeerMessageType.NodeSummary, {
                    ownVersion: decodeInteger(decoder),
                    nodes: decodeArray(decoder, () => ({
                        id: decodeId(decoder),
                        version: decodeInteger(decoder)
                    }))
                }];
        case tags_1.TAG_NODE_REQUEST:
            return [messages_1.PeerMessageType.NodeRequest, {
                    nodes: decodeArray(decoder, decodeId)
                }];
        case tags_1.TAG_NODE_DETAILS:
            return [messages_1.PeerMessageType.NodeDetails, {
                    nodes: decodeArray(decoder, () => ({
                        id: decodeId(decoder),
                        version: decodeInteger(decoder),
                        neighbors: decodeArray(decoder, () => ({
                            id: decodeId(decoder),
                            latency: decodeInteger(decoder)
                        }))
                    }))
                }];
        case tags_1.TAG_DATA:
            return [messages_1.PeerMessageType.Data, {
                    target: decodeId(decoder),
                    type: decodeString(decoder),
                    data: decodeBuffer(decoder),
                    path: decodeArray(decoder, () => ({
                        node: decodeId(decoder),
                        id: decodeInteger(decoder)
                    }))
                }];
        case tags_1.TAG_DATA_ACK:
            return [messages_1.PeerMessageType.DataAck, {
                    id: decodeInteger(decoder)
                }];
        case tags_1.TAG_DATA_REJECT:
            return [messages_1.PeerMessageType.DataReject, {
                    id: decodeInteger(decoder)
                }];
        default:
            return null;
    }
}
exports.decodeBinaryPeerMessage = decodeBinaryPeerMessage;
/**
 * Decode an identifier.
 *
 * @param decoder -
 * @returns
 *   identifier
 */
function decodeId(decoder) {
    const decoded = decoder.decode();
    return decoded.buffer;
}
/**
 * Decode an array.
 *
 * @param decoder -
 * @param readItem -
 *   callback used to read items
 * @returns
 *   array with items
 */
function decodeArray(decoder, readItem) {
    const items = decoder.decode();
    const result = [];
    for (let i = 0; i < items; i++) {
        result.push(readItem(decoder));
    }
    return result;
}
/**
 * Decode an integer.
 *
 * @param decoder -
 * @returns
 *   integer value
 */
function decodeInteger(decoder) {
    return decoder.decode();
}
/**
 * Decode a buffer.
 *
 * @param decoder -
 * @returns
 *   buffer
 */
function decodeBuffer(decoder) {
    return decoder.decode().buffer;
}
/**
 * Decode a string.
 *
 * @param decoder -
 * @returns
 *   string
 */
function decodeString(decoder) {
    return decoder.decode();
}
//# sourceMappingURL=decodeBinaryPeerMessage.js.map