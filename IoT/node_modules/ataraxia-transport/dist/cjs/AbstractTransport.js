"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractTransport = void 0;
const atvik_1 = require("atvik");
const debug_1 = __importDefault(require("debug"));
const ids_1 = require("./ids");
/**
 * Abstract base for implementing transports. Implements common behavior to
 * help with tracking of peers.
 */
class AbstractTransport {
    /**
     * Create a new instance.
     *
     * @param name -
     *   name of the transport, should be short and identify, examples from the
     *   core library include `local`, `tcp` and `hyperswarm`.
     */
    constructor(name) {
        this.peerConnectEvent = new atvik_1.Event(this);
        this.peers = new Set();
        this._started = false;
        this.transportName = name;
        this.debug = (0, debug_1.default)('ataraxia:no-network:' + name);
    }
    get transportOptions() {
        if (!this._transportOptions) {
            throw new Error();
        }
        return this._transportOptions;
    }
    /**
     * Event for when a new peer is connected via this transport.
     *
     * @returns
     *   `Subscribable` that can be used to register listeners
     */
    get onPeerConnect() {
        return this.peerConnectEvent.subscribable;
    }
    /**
     * Get if transport is started.
     *
     * @returns
     *   `true` if transport is started
     */
    get started() {
        return this._started;
    }
    /**
     * Start this transport.
     *
     * @param options -
     *   options as generated by the network instance
     * @returns
     *   boolean indicating if the transport was started
     */
    async start(options) {
        if (this._started) {
            return false;
        }
        this.debug = (0, debug_1.default)('ataraxia:' + options.networkName + ':' + this.transportName);
        this._started = true;
        this._transportOptions = options;
        this.debug('Starting with id ' + (0, ids_1.encodeId)(options.networkId));
        return true;
    }
    /**
     * Stop this transport.
     *
     * @returns
     *   boolean indicating if the transport was stopped.
     */
    async stop() {
        if (!this._started) {
            return false;
        }
        for (const peer of this.peers.values()) {
            peer.disconnect();
        }
        this._started = false;
        return true;
    }
    /**
     * Add a peer to this transport. This will start monitoring this peer
     * for connection events and make it available/unavailable as it
     * connects/disconnects.
     *
     * @param peer -
     *   peer to track
     */
    addPeer(peer) {
        const onConnect = () => {
            // New peer, connect to it
            this.peers.add(peer);
            this.debug('Peer with id', (0, ids_1.encodeId)(peer.id), 'is now available');
            this.peerConnectEvent.emit(peer);
        };
        peer.onConnect(onConnect);
        peer.onDisconnect(() => {
            this.peers.delete(peer);
            this.debug('Peer with id', (0, ids_1.encodeId)(peer.id), 'is no longer available');
        });
        if (peer.connected) {
            // If adding an already connected peer run connect routine
            onConnect();
        }
    }
}
exports.AbstractTransport = AbstractTransport;
//# sourceMappingURL=AbstractTransport.js.map